# This file was generated based on ".graphqlconfig". Do not edit manually.

schema {
    query: Query
    mutation: Mutation
}

interface Paginated {
    "current page number"
    pageNumber: Int!
    "maximum size of the page currently returned"
    pageSize: Int!
    "total number of results"
    total: Int!
}

type Artery {
    county: County!
    id: Int!
    loc: Loc!
    "Name of the artery"
    name: String!
    "Prefix to show when displaying the value"
    prefix: String!
    uat: Uat!
    "Unique reference into MFP files"
    uname: String!
}

type Collection {
    "Date the event was recorded in the cloud"
    arrivedAt: DateTime!
    collectedStream: WasteStream
    county: County!
    "Date the event was recorded in the field"
    createdAt: DateTime!
    "Only allowed in debug mode"
    extId: String!
    "Group record at the time collection was created (createdAt used as reference)"
    group: Group
    id: Int!
    intendedStream: WasteStream
    posLat: Float!
    posLng: Float!
    "Recipient record at the time collection was created"
    recipient: Recipient
    source: CollectionSource!
    status: CollectionStatus!
    tag: String!
    uat: Uat!
    vehicleLicensePlate: String!
}

type County {
    "Unique ID of this county. Matches MFP nomenclator."
    id: Int!
    "Name of county, usually all caps."
    name: String!
    "Display sequence number. Sort by this sequence instead of the ID when displaying multiple counties in a list"
    seq: Int!
    "Short code for county, as seen on vehicle license plates. Ex SB for Sibiu."
    short: String!
    uats: [Uat!]!
    "Unique reference into MFP nomenclator files."
    uname: String!
}

type Group {
    "Street Number"
    addressNumber: String!
    addressStreet: String!
    collections(
        "Page Number"
        pageNumber: Int,
        "Results per page. Max 100."
        pageSize: Int
    ): PaginatedCollections!
    comments: String!
    county: County!
    current: Boolean!
    eosId: String!
    from: DateTime!
    "Whether this object is hidden by default or not"
    hidden: Boolean!
    id: Int!
    labels: [Label!]!
    loc: Loc!
    recipients(
        from: DateTime,
        "Type of records to return for this historical query"
        historicalRecordType: HistoricalRecordType,
        to: DateTime
    ): [Recipient!]!
    to: DateTime!
    type: GroupType!
    uat: Uat!
    users(
        from: DateTime,
        "Type of records to return for this historical query"
        historicalRecordType: HistoricalRecordType,
        to: DateTime
    ): [User!]!
}

type GroupMap {
    center: GroupMapLngLat!
    data: String!
    max: GroupMapLngLat!
    min: GroupMapLngLat!
}

type GroupMapLngLat {
    posLat: Float!
    posLng: Float!
}

type Label {
    name: String!
    value: String
}

type Loc {
    arteries: [Artery!]!
    county: County!
    id: Int!
    name: String!
    posLat: Float!
    posLng: Float!
    uat: Uat!
    uname: String!
}

type Mutation {
    createCollection(input: CollectionCreateInput!): CollectionStatus!
    createGroup(input: GroupCreateInput!): Group!
    createRecipient(input: RecipientCreateInput!): Recipient!
    createUser(input: UserCreateInput!): User!
    deleteVehicleTrip(id: Int!): VehicleTrip!
    saveVehicleTrip(input: VehicleTripInput!): VehicleTrip!
    updateGroup(eosId: String!, input: GroupUpdateInput!): Group!
    updateRecipient(eosId: String!, input: RecipientUpdateInput!): Recipient!
    updateRecipientTag(input: RecipientTagUpdateInput!, tag: String!): RecipientTag!
    updateUser(eosId: String!, input: UserUpdateInput!): User!
}

type PaginatedCollections implements Paginated {
    items: [Collection!]!
    "current page number"
    pageNumber: Int!
    "maximum size of the page currently returned"
    pageSize: Int!
    "total number of results"
    total: Int!
}

type PaginatedGroups implements Paginated {
    "groups in the page"
    items: [Group!]!
    "current page number"
    pageNumber: Int!
    "maximum size of the page currently returned"
    pageSize: Int!
    "total number of results"
    total: Int!
}

type PaginatedRecipientTags implements Paginated {
    "recipient tags in the page"
    items: [RecipientTag!]!
    "current page number"
    pageNumber: Int!
    "maximum size of the page currently returned"
    pageSize: Int!
    "total number of results"
    total: Int!
}

type PaginatedRecipients implements Paginated {
    "recipients in the page"
    items: [Recipient!]!
    "current page number"
    pageNumber: Int!
    "maximum size of the page currently returned"
    pageSize: Int!
    "total number of results"
    total: Int!
}

type PaginatedSearchResults implements Paginated {
    "search results in the page"
    items: [SearchResult!]!
    "current page number"
    pageNumber: Int!
    "maximum size of the page currently returned"
    pageSize: Int!
    "total number of results"
    total: Int!
}

type PaginatedUsers implements Paginated {
    "users in the page"
    items: [User!]!
    "current page number"
    pageNumber: Int!
    "maximum size of the page currently returned"
    pageSize: Int!
    "total number of results"
    total: Int!
}

type PaginatedVehicleTrips {
    items: [VehicleTrip!]!
    "Id for 'after' parameter of next page"
    nextId: Int
    pageSize: Int!
    "Id for 'after' parameter of previous page. Not implemented"
    prevId: Int
    "Total number of results. Not implemented."
    total: Int
}

type Profile {
    counties: [County!]!
    "Email of this user"
    email: String!
    "Unique user-id. Usually maps on to OIDC provider's GUID"
    id: String!
    "Name of this user."
    name: String!
    "Array of roles this user is part of. Can be null if user has no roles assigned."
    roles: [String!]
    uats: [Uat!]!
    "Username of this user. Usually unique, but not guaranteed."
    username: String!
}

type Query {
    arteries(countyIds: [Int!], locIds: [Int!], uatIds: [Int!]): [Artery!]!
    collections(
        arrivedAt: QueryCollectionDateFilter,
        "County IDs to restrict query to"
        countyIds: [Int!],
        createdAt: QueryCollectionDateFilter,
        "Return collections that only correspond to certain group ids"
        groupIds: [String!],
        "Page Number"
        pageNumber: Int,
        "Results per page. Max 100."
        pageSize: Int,
        "Return collections that only correspond to certain recipient ids"
        recipientIds: [String!],
        "Only return collections that have the specified status"
        status: [CollectionStatus!],
        "UAT IDs to restrict query"
        uatIds: [Int!],
        "Only return collections that have the specified vehicleLicensePlates set"
        vehicleLicensePlates: [String!]
    ): PaginatedCollections!
    counties: [County!]!
    groupMap: GroupMap!
    groups(
        "For delta queries"
        afterId: Int,
        "County IDs to restrict query to"
        countyIds: [Int!],
        eosIds: [String!],
        from: DateTime,
        "State of hideables to show"
        hideableState: HideableState,
        "Type of records to return for this historical query"
        historicalRecordType: HistoricalRecordType,
        "Labels that must be present on the object"
        labels: [String!],
        "Loc ids to restrict query to"
        locIds: [Int!],
        "Page Number"
        pageNumber: Int,
        "Results per page. Max 100."
        pageSize: Int,
        "Street name to query (can be inexact)"
        street: String,
        to: DateTime,
        types: [GroupType!],
        "UAT IDs to restrict query"
        uatIds: [Int!]
    ): PaginatedGroups!
    locs(countyIds: [Int!], uatIds: [Int!]): [Loc!]!
    "Current user's profile"
    me: Profile
    recipientTags(
        "Used for delta queries. Requires DISABLE_PAGINATION role"
        afterId: Int,
        "County IDs to restrict query to"
        countyIds: [Int!],
        from: DateTime,
        "Type of records to return for this historical query"
        historicalRecordType: HistoricalRecordType,
        "Page Number"
        pageNumber: Int,
        "Results per page. Max 100."
        pageSize: Int,
        to: DateTime,
        "UAT IDs to restrict query"
        uatIds: [Int!]
    ): PaginatedRecipientTags!
    recipients(
        "Used for delta queries. Requires DISABLE_PAGINATION role"
        afterId: Int,
        altIds: [String!],
        "County IDs to restrict query to"
        countyIds: [Int!],
        eosIds: [String!],
        from: DateTime,
        groupIds: [String!],
        "State of hideables to show"
        hideableState: HideableState,
        "Type of records to return for this historical query"
        historicalRecordType: HistoricalRecordType,
        "Labels that must be present on the object"
        labels: [String!],
        "Loc ids to restrict query to"
        locIds: [Int!],
        "Page Number"
        pageNumber: Int,
        "Results per page. Max 100."
        pageSize: Int,
        sizes: [String!],
        streams: [WasteStream!],
        "Street name to query (can be inexact)"
        street: String,
        to: DateTime,
        "UAT IDs to restrict query"
        uatIds: [Int!]
    ): PaginatedRecipients!
    recommendedLabels: [RecommendedLabel!]!
    search(
        "County IDs to restrict query to"
        countyIds: [Int!],
        locIds: [Int!],
        "Page Number"
        pageNumber: Int,
        "Results per page. Max 100."
        pageSize: Int,
        q: String!,
        types: [EosObjectType!],
        "UAT IDs to restrict query"
        uatIds: [Int!]
    ): PaginatedSearchResults!
    stat: Stat!
    uats(countyIds: [Int!]): [Uat!]!
    users(
        "County IDs to restrict query to"
        countyIds: [Int!],
        eosIds: [String!],
        extIds: [String!],
        from: DateTime,
        groupTypes: [GroupType!],
        "State of hideables to show"
        hideableState: HideableState,
        "Type of records to return for this historical query"
        historicalRecordType: HistoricalRecordType,
        "Labels that must be present on the object"
        labels: [String!],
        "Loc ids to restrict query to"
        locIds: [Int!],
        "Page Number"
        pageNumber: Int,
        "Results per page. Max 100."
        pageSize: Int,
        "Street name to query (can be inexact)"
        street: String,
        to: DateTime,
        types: [UserType!],
        "UAT IDs to restrict query"
        uatIds: [Int!]
    ): PaginatedUsers!
    vehicleTrips(
        date: VehicleTripDateFilter,
        id: [Int!],
        "Maximum number of results per page. Max 200."
        maxResultsPerPage: Int,
        "Id after which to begin "
        pageAfter: Int,
        stream: [WasteStream!],
        vehicleLicensePlate: [String!]
    ): PaginatedVehicleTrips!
    vehicles: [Vehicle!]!
}

type Recipient {
    "Street Number"
    addressNumber: String!
    addressStreet: String!
    altId: String
    collections(
        "Page Number"
        pageNumber: Int,
        "Results per page. Max 100."
        pageSize: Int
    ): PaginatedCollections!
    comments: String!
    county: County!
    current: Boolean!
    eosId: String!
    from: DateTime!
    "Group entries with which this recipient entry is associated"
    groups(
        from: DateTime,
        "Type of records to return for this historical query"
        historicalRecordType: HistoricalRecordType,
        to: DateTime
    ): [Group!]!
    "Whether this object is hidden by default or not"
    hidden: Boolean!
    id: Int!
    labels: [Label!]!
    loc: Loc!
    "Last known latitude"
    posLat: Float!
    "Last known longitude"
    posLng: Float!
    size: String!
    stream: WasteStream!
    tag0(
        from: DateTime,
        "Type of records to return for this historical query"
        historicalRecordType: HistoricalRecordType,
        to: DateTime
    ): [RecipientTag!]!
    tag1(
        from: DateTime,
        "Type of records to return for this historical query"
        historicalRecordType: HistoricalRecordType,
        to: DateTime
    ): [RecipientTag!]!
    to: DateTime!
    uat: Uat!
}

type RecipientTag {
    current: Boolean!
    from: DateTime!
    id: Int!
    recipient(
        from: DateTime,
        "Type of records to return for this historical query"
        historicalRecordType: HistoricalRecordType,
        to: DateTime
    ): [Recipient!]!
    slot: Int!
    tag: String!
    to: DateTime!
}

type RecommendedLabel {
    "The text to show when this label is used"
    displayName: String!
    "Name of the label that will be found in the labels[] array"
    label: String!
}

type SearchResult {
    group: Group
    highlight: SearchResultHighlight!
    recipient: Recipient
    user: User
}

type SearchResultHighlight {
    addressNumber: String
    addressStreet: String
    extId: String
    id: String
    name: String
}

type Stat {
    collectionCount: [StatCollectionBucket!]!
    userCountPerCategory: [UserCountPerCategory!]!
}

type StatCollectionBucket {
    end: DateTime!
    start: DateTime!
    values: [StatCollectionBucketValues!]!
}

type StatCollectionBucketValues {
    size: String!
    value: Int!
}

type Uat {
    arteries: [Artery!]!
    county: County!
    id: Int!
    locs: [Loc!]!
    name: String!
    uname: String!
}

type User {
    "Street Number"
    addressNumber: String!
    addressStreet: String!
    attributes: [UserAttribute!]!
    comments: String!
    county: County!
    current: Boolean!
    eosId: String!
    "External ID used to interface this user to other systems"
    extId: String
    from: DateTime!
    "Group entries with which this user entry is associated"
    groups(
        from: DateTime,
        "Type of records to return for this historical query"
        historicalRecordType: HistoricalRecordType,
        "Page Number"
        pageNumber: Int,
        "Results per page. Max 100."
        pageSize: Int,
        to: DateTime
    ): PaginatedGroups!
    "Whether this object is hidden by default or not"
    hidden: Boolean!
    id: Int!
    idNumber: String!
    labels: [Label!]!
    loc: Loc!
    name: String!
    to: DateTime!
    type: UserType!
    uat: Uat!
}

type UserAttribute {
    name: String!
    value: String!
}

type UserCountPerCategory {
    count: Int!
    groupType: GroupType!
    userType: UserType!
}

type Vehicle {
    county: County!
    licensePlate: String!
}

type VehicleTrip {
    county: County!
    editedAt: DateTime!
    editedBy: String!
    end: DateTime!
    id: Int!
    start: DateTime!
    stream: WasteStream!
    vehicleLicensePlate: String!
}

"The source of this reading"
enum CollectionSource {
    LEFT_ANTENNA
    MANUAL
    RIGHT_ANTENNA
    SIDE_ANTENNA
}

"Status of collection resolution process"
enum CollectionStatus {
    PENDING
    SUCCESSFUL
    TIMED_OUT
    UNSUCCESSFUL
}

"eos object type enum"
enum EosObjectType {
    GROUP
    RECIPIENT
    USER
}

"The type of group. Subject to change in the future"
enum GroupType {
    AE
    DM
    PM
    PX
}

"State of hideables to show."
enum HideableState {
    ANY
    HIDDEN
    VISIBLE
}

"Type of historical record to return for an object"
enum HistoricalRecordType {
    CURRENT_ONLY
    FULL
    HISTORY_ONLY
    INHERIT
}

"User type"
enum UserType {
    BUSINESS
    DOMESTIC
}

"Waste stream type. REZ = Residual, RPC/RGL/RPM = Recyclable, BIO = Biodegradable"
enum WasteStream {
    BIO
    REZ
    RGL
    RPC
    RPM
}

input CollectionCreateInput {
    arrivedAt: DateTime!
    countyId: Int
    createdAt: DateTime!
    "UUID"
    extId: String!
    ignoreTimeout: Boolean
    posLat: Float!
    posLng: Float!
    source: CollectionSource!
    tag: String!
    vehicleLicensePlate: String!
}

input GroupCreateInput {
    addressNumber: String!
    addressStreet: String!
    comments: String
    countyId: Float!
    "Object hidden or not"
    hidden: Boolean!
    "Full label array"
    labels: [LabelInput!]!
    locId: Int!
    type: GroupType!
    uatId: Int!
}

input GroupUpdateInput {
    addressNumber: String
    addressStreet: String
    comments: String
    "Object hidden or not"
    hidden: Boolean
    "Full label array"
    labels: [LabelInput!]
    locId: Int
    type: GroupType
    uatId: Int
}

input LabelInput {
    name: String!
    value: String
}

input QueryCollectionDateFilter {
    from: DateTime
    to: DateTime
}

input RecipientCreateInput {
    addressNumber: String!
    addressStreet: String!
    altId: String
    comments: String!
    countyId: Int!
    groupId: String
    "Object hidden or not"
    hidden: Boolean!
    "Full label array"
    labels: [LabelInput!]!
    locId: Int!
    posLat: Float!
    posLng: Float!
    size: String!
    stream: WasteStream!
    uatId: Int!
}

input RecipientTagUpdateInput {
    recipientId: String
    slot: Int!
}

input RecipientUpdateInput {
    addressNumber: String
    addressStreet: String
    comments: String
    groupId: String
    "Object hidden or not"
    hidden: Boolean
    "Full label array"
    labels: [LabelInput!]
    locId: Int
    posLat: Float
    posLng: Float
    size: String
    stream: WasteStream
    uatId: Int
}

input UserAttributeInput {
    name: String!
    value: String!
}

input UserCreateInput {
    addressNumber: String!
    addressStreet: String!
    attributes: [UserAttributeInput!]!
    comments: String!
    countyId: Int!
    "External ID used to interface this user to other systems"
    extId: String
    groupId: String
    "Object hidden or not"
    hidden: Boolean!
    idNumber: String!
    "Full label array"
    labels: [LabelInput!]!
    locId: Int!
    name: String!
    type: UserType!
    uatId: Int!
}

input UserUpdateInput {
    addressNumber: String
    addressStreet: String
    attributes: [UserAttributeInput!]
    comments: String
    "External ID used to interface this user to other systems"
    extId: String
    groupId: String
    "Object hidden or not"
    hidden: Boolean
    idNumber: String
    "Full label array"
    labels: [LabelInput!]
    locId: Int
    name: String
    type: UserType
    uatId: Int
}

input VehicleTripDateFilter {
    from: DateTime
    to: DateTime
}

input VehicleTripInput {
    end: DateTime!
    "Trip id, if editing an existing trip"
    id: Int
    start: DateTime!
    stream: WasteStream!
    vehicleLicensePlate: String
}


"The javascript `Date` as string. Type represents date and time as the ISO Date string."
scalar DateTime