# This file was generated based on ".graphqlconfig". Do not edit manually.

schema {
    query: Query
    mutation: Mutation
}

interface GroupBase {
    active: Boolean!
    comments: String!
    id: String!
    labels: [String!]!
    type: GroupType!
}

interface RecipientBase {
    active: Boolean!
    addressNumber: String!
    addressStreet: String!
    comments: String!
    id: String!
    labels: [String!]!
    "Last known latitude"
    posLat: Float!
    "Last known longitude"
    posLng: Float!
    size: String!
    stream: WasteStream!
}

interface RecipientTagBase {
    slot: Int!
    tag: String!
}

interface UserBase {
    active: Boolean!
    addressNumber: String!
    addressStreet: String!
    billingType: BillingType!
    comments: String!
    id: String!
    idNumber: String!
    labels: [String!]!
    name: String!
    type: UserType!
}

union UserBillingData = UserBillingData_Fixed | UserBillingData_PerPerson | UserBillingData_PerPerson_RA

type Artery {
    county: County!
    id: Int!
    loc: Loc!
    "Name of the artery"
    name: String!
    "Prefix to show when displaying the value"
    prefix: String!
    uat: Uat!
    "Unique reference into MFP files"
    uname: String!
}

type BillSchedule {
    endMonth: Int!
    startMonth: Int!
    year: Int!
}

type BillSummaryItem {
    text: String!
    type: BillSummaryItemType!
    unit: BillSummaryItemUnit
    value: String!
}

type Collection {
    arrivedAt: Int!
    county: County
    createdAt: Int!
    externalId: String!
    group: Group
    id: Int!
    posLat: Float!
    posLng: Float!
    recipient: Recipient
    source: CollectionSource!
    status: CollectionStatus!
    stream: WasteStream
    tag: String!
    uat: Uat
    vehicleLicensePlate: String!
}

type County {
    "Unique ID of this county. Matches MFP nomenclator."
    id: Int!
    "Name of county, usually all caps."
    name: String!
    "Display sequence number. Sort by this sequence instead of the ID when displaying multiple counties in a list"
    seq: Int!
    "Short code for county, as seen on vehicle license plates. Ex SB for Sibiu."
    short: String!
    uats: [Uat!]!
    "Unique reference into MFP nomenclator files."
    uname: String!
}

type Group implements GroupBase {
    active: Boolean!
    collections(range: FromToFilter): [Collection!]!
    comments: String!
    county: County!
    currentRecipients: [GroupRecipient!]!
    currentUsers: [GroupUser!]!
    id: String!
    labels: [String!]!
    recipientHistory(range: FromToFilter): [GroupRecipient!]!
    type: GroupType!
    uat: Uat!
    userHistory(range: FromToFilter): [GroupUser!]!
}

type GroupRecipient {
    current: Boolean!
    group: Group
    recipient: Recipient!
    validFrom: Timestamp!
    validTo: Timestamp!
}

type GroupUser {
    current: Boolean!
    group: Group
    user: User!
    validFrom: Timestamp!
    validTo: Timestamp!
}

type Loc {
    arteries: [Artery!]!
    county: County!
    id: Int!
    name: String!
    posLat: Float!
    posLng: Float!
    uat: Uat!
    uname: Int!
}

type Mutation {
    allocateGroups(count: Int!, countyId: Int!, type: GroupType!): [RawGroup!]!
    allocateRecipients(count: Int!, countyId: Int!, stream: WasteStream!): [RawRecipient!]!
    allocateUser(count: Int!, countyId: Int!, type: UserType!): [RawUser!]!
    "To be used for assigning tasks"
    assignTasks(assignedTo: String!, ids: [Int!]!): [Task!]!
    createCollection(arrivedAt: Int!, createdAt: Int!, externalId: String!, posLat: Float!, posLng: Float!, source: String!, tag: String!, vehicleLicensePlate: String!): CollectionStatus!
    "Creates a task and optionally assigns it."
    createTask(task: TaskInput!): Task!
    editGroup(
        associatedTaskId: Int,
        #Unix timestamp when this edit was created on local device
        createdAt: Int!,
        #Edits to be made to the group
        group: GroupInput!,
        #Id of the group to be edited
        groupId: String!,
        transactionId: String
    ): RawGroup!
    editRecipient(
        associatedTaskId: Int,
        #Unix Timestamp of when the patch was created
        createdAt: Int!,
        recipient: RecipientInput!,
        recipientId: String!,
        transactionId: String
    ): RawRecipient!
    "Edits task values. Throws an error if the task has been assigned"
    editTask(id: Int!, task: TaskInput!): Task!
    editUser(associatedTaskId: Int, createdAt: Int!, transactionId: String, user: UserInput!, userId: String!): RawUser!
    "Use to apply a series of patches, along with an optional final patch"
    patchGroup(
        #Final group state before patches are approved.
        group: GroupInput!,
        groupId: String!,
        #Patches that are to be applied
        patches: [Int!]!
    ): PatchResponse
    "Use to apply a series of patches, along with an optional final patch"
    patchRecipient(
        #Patches that are to be applied
        patches: [Int!]!,
        #Final recipient state before patches are approved.
        recipient: RecipientInput!,
        recipientId: String!
    ): PatchResponse!
    patchUser(
        #Patches that are to be applied
        patches: [Int!]!,
        #Final user state before patches are approved.
        user: UserInput!,
        userId: String!
    ): PatchResponse!
    "Submits a transaction, making its associated edits visible in the system"
    submitTransaction(transactionId: String!): String!
    "To be used for task updates from limited-connectivity devies"
    updateTask(gid: String, id: Int, task: TaskInput!, updatedAt: Int!): Task!
}

type Patch {
    arrivedAt: Int!
    associatedTask: Task
    createdAt: Int!
    createdBy: String!
    id: Int!
    patch: String!
    state: PatchState!
}

type PatchResponse {
    pendingGroups: [String!]
    pendingRecipients: [String!]
    pendingUsers: [String!]
    "Patch application state. APPLIED means everything is done, ACCEPTED means a transaction is still pending"
    state: PatchState!
}

type Query {
    arteries(countyIds: [Int!], locIds: [Int!], uatIds: [Int!]): [Artery!]!
    collections(
        arrivedAt: FromToFilter,
        countyIds: [Int!],
        createdAt: FromToFilter,
        groupIds: [String!],
        #Maximum number of results per page. Max 200.
        maxResultsPerPage: Int,
        #Id after which to begin
        pageAfter: Int,
        recipientIds: [String!],
        status: [CollectionStatus!],
        #Limit results to a particular vehicle license plate
        vehicleLicensePlate: [String!]
    ): [Collection!]!
    counties: [County!]!
    groups(
        #Whether to return active (true) or inactive (false) groups. Default [true]
        active: [Boolean!],
        #County IDs to restrict query to
        countyIds: [Int!],
        ids: [String!],
        labels: [String!],
        #Maximum number of results per page
        maxResultsPerPage: Int,
        #Id after which to start the page
        pageAfter: String,
        types: [GroupType!],
        uatIds: [Int!]
    ): [Group!]!
    locs(countyIds: [Int!], uatIds: [Int!]): [Loc!]!
    rawGroups(hasPendingChanges: Boolean, ids: [String!], labels: [String!], maxResultsPerPage: Int, pageAfter: String, updatedAfter: Int): [RawGroup!]!
    rawRecipients(hasPendingChanges: Boolean, ids: [String!], labels: [String!], maxResultsPerPage: Int, pageAfter: String, updatedAfter: Int): [RawRecipient!]!
    rawSearch(
        countyIds: [Int!],
        #Maximum number of results to return, max allowed is 100.
        maxResults: Int,
        q: String!,
        types: [SearchResultType!],
        uatIds: [Int!]
    ): [RawSearchResult!]!
    rawUsers(hasPendingChanges: Boolean, ids: [String!], labels: [String!], maxResultsPerPage: Int, pageAfter: String, updatedAfter: Int): [RawUser!]!
    recipients(
        #Whether to return active (true) or inactive (false) recipients. Default [true]
        active: [Boolean!],
        #County IDs to restrict query to
        countyIds: [Int!],
        ids: [String!],
        labels: [String!],
        locIds: [Int!],
        #Maximum number of results per page
        maxResultsPerPage: Int,
        #Id after which to return results
        pageAfter: String,
        sizes: [String!],
        uatIds: [Int!]
    ): [Recipient!]!
    recommendedLabels: [RecommendedLabel!]!
    search(
        countyIds: [Int!],
        #Maximum number of results to return, max allowed is 100.
        maxResults: Int,
        q: String!,
        types: [SearchResultType!],
        uatIds: [Int!]
    ): [SearchResult!]!
    stat: Stat!
    "List of people tasks can be assigned to"
    taskAssigneeList: [String!]!
    taskSearch(
        #Use empty string to select \"unassigned\" tasks
        assignedTo: [String!],
        countyIds: [Int!],
        #Maximum number of results to return
        maxResults: Int,
        q: String!,
        status: [TaskStatus!],
        uatIds: [Int!]
    ): [TaskSearchResult!]!
    "Note: since conditions are additive, you cannot search by ID or GID in the same query, you must use separate queries"
    tasks(assignedTo: [String!], countyIds: [Int!], gids: [String!], ids: [Int!], maxResultsPerPage: Int, pageAfter: Int, status: [TaskStatus!], uatIds: [Int!]): [Task!]!
    uats(countyIds: [Int!]): [Uat!]!
    users(
        active: [Boolean!],
        billingTypes: [BillingType!],
        countyIds: [Int!],
        groupTypes: [GroupType!],
        ids: [String!],
        labels: [String!],
        locIds: [Int!],
        #Maximum number of results per page
        maxResultsPerPage: Int,
        #Id after which to start page
        pageAfter: String,
        types: [UserType!],
        uatIds: [Int!]
    ): [User!]!
}

type RawGroup implements GroupBase {
    active: Boolean!
    associatedTasks: [Task!]!
    "Accepted or applied patches to this object"
    changeHistory: [Patch!]!
    comments: String!
    county: County!
    id: String!
    labels: [String!]!
    pendingChanges: [Patch!]!
    recipients: [RawRecipient!]!
    type: GroupType!
    uat: Uat!
    updatedAt: Int!
    users: [RawUser!]!
}

type RawRecipient implements RecipientBase {
    active: Boolean!
    addressNumber: String!
    addressStreet: String!
    associatedTasks: [Task!]!
    "Accepted or applied patches to this object"
    changeHistory: [Patch!]!
    comments: String!
    county: County!
    groupId: String
    id: String!
    labels: [String!]!
    loc: Loc!
    pendingChanges: [Patch!]!
    "Last known latitude"
    posLat: Float!
    "Last known longitude"
    posLng: Float!
    size: String!
    stream: WasteStream!
    "Recipient tags. Only visible with Logistics->Tags->View option"
    tags: [RawRecipientTag!]
    uat: Uat!
    updatedAt: Int!
}

type RawRecipientTag implements RecipientTagBase {
    slot: Int!
    tag: String!
}

type RawSearchResult {
    group: RawGroup
    highlight: SearchResultHighlight!
    recipient: RawRecipient
    user: RawUser
}

type RawUser implements UserBase {
    active: Boolean!
    addressNumber: String!
    addressStreet: String!
    associatedTasks: [Task!]!
    billingData: UserBillingData
    billingType: BillingType!
    "Accepted or applied patches to this object"
    changeHistory: [Patch!]!
    comments: String!
    county: County!
    groupId: String
    id: String!
    idNumber: String!
    labels: [String!]!
    loc: Loc!
    name: String!
    pendingChanges: [Patch!]!
    type: UserType!
    uat: Uat!
    updatedAt: Int!
}

type Recipient implements RecipientBase {
    active: Boolean!
    addressNumber: String!
    addressStreet: String!
    collections(range: FromToFilter): [Collection!]!
    comments: String!
    county: County!
    currentGroup: GroupRecipient
    groupHistory(range: FromToFilter): [GroupRecipient!]!
    id: String!
    labels: [String!]!
    loc: Loc!
    "Last known latitude"
    posLat: Float!
    "Last known longitude"
    posLng: Float!
    size: String!
    stream: WasteStream!
    tags: [RecipientTag!]!
    uat: Uat!
}

type RecipientTag implements RecipientTagBase {
    slot: Int!
    tag: String!
}

type RecommendedLabel {
    "The text to show when this label is used"
    displayName: String!
    "Name of label that will be found in the labels[] array"
    label: String!
}

type SearchResult {
    group: Group
    highlight: SearchResultHighlight!
    recipient: Recipient
    user: User
}

type SearchResultHighlight {
    addressNumber: String
    addressStreet: String
    id: String
    name: String
}

type Stat {
    collectionCount: [StatCollectionBucket!]!
    userCountPerCategory: StatUser!
}

type StatCollectionBucket {
    end: Timestamp!
    start: Timestamp!
    values: [StatCollectionBucketValues!]!
}

type StatCollectionBucketValues {
    size: String!
    value: Int!
}

type StatUser {
    business: StatUserBusiness!
    domestic: StatUserDomestic!
}

type StatUserBusiness {
    administrative: Int!
    industrial: Int!
}

type StatUserDomestic {
    condominium: Int!
    flat: Int!
    home: Int!
}

type Task {
    assignedTo: String
    comments: String!
    county: County!
    current: Boolean!
    gid: String
    groups: [RawGroup!]!
    history: [Task!]!
    id: Int!
    loc: Loc!
    posLat: Float
    posLng: Float
    recipients: [RawRecipient!]!
    status: TaskStatus!
    uat: Uat!
    updatedAt: Timestamp!
    updatedBy: String!
    users: [RawUser!]!
    validFrom: Timestamp!
    validTo: Timestamp!
}

type TaskSearchHighlights {
    gid: String
    groupIds: String
    id: String
    recipientIds: String
    userIds: String
}

type TaskSearchResult {
    highlights: TaskSearchHighlights!
    task: Task!
}

type Uat {
    arteries: [Artery!]!
    county: County!
    id: Int!
    locs: [Uat!]!
    name: String!
    uname: String!
}

type User implements UserBase {
    active: Boolean!
    addressNumber: String!
    addressStreet: String!
    bill(schedule: BillScheduleInput): UserBill
    billingData: UserBillingData
    billingType: BillingType!
    comments: String!
    county: County!
    current: Boolean!
    currentGroup: GroupUser
    groupHistory(range: FromToFilter): [GroupUser!]!
    history(range: FromToFilter): [User!]!
    id: String!
    idNumber: String!
    labels: [String!]!
    loc: Loc!
    name: String!
    stat: UserStat
    type: UserType!
    uat: Uat!
    validFrom: Timestamp!
    validTo: Timestamp!
}

type UserBill {
    consolidatedUrl: String!
    itemisedUrl: String!
    schedule: BillSchedule!
    summary: [BillSummaryItem!]!
}

type UserBillingData_Fixed {
    fixedComponents: [UserBillingData_Fixed_Component!]!
}

type UserBillingData_Fixed_Component {
    collections: Int!
    size: String!
    stream: WasteStream!
}

type UserBillingData_PerPerson {
    persons: Int!
}

type UserBillingData_PerPerson_RA {
    persons: Int!
    ra: [UserBillingData_PerPerson_RA_Month!]!
}

type UserBillingData_PerPerson_RA_Month {
    month: String!
    value: Boolean!
}

type UserStat {
    collectionDays: [String!]
    collectionWeight: String
    collectionsPerMonth: Float
    penaltiesPerYear: Float
}

"Label operations. Add/remove available."
enum ArrayOp {
    ADD
    REMOVE
}

"Bill item type"
enum BillSummaryItemType {
    CollectionsExtra
    CollectionsIncluded
    CollectionsPenalty
    Total
    TotalExtra
    TotalPenalty
}

"Unit the item is in"
enum BillSummaryItemUnit {
    Count
    Lei
}

"User billing type"
enum BillingType {
    FIXED
    NONE
    PER_PERSON
    PER_PERSON_RA
}

"The source of this reading"
enum CollectionSource {
    LEFT_ANTENNA
    MANUAL
    RIGHT_ANTENNA
    SIDE_ANTENNA
}

"Status of collection resolution process"
enum CollectionStatus {
    PENDING
    SUCCESSFUL
    TIMED_OUT
    UNSUCCESSFUL
}

"The type of group, see enums for more details."
enum GroupType {
    AE
    DM
    PM
    PX
}

"Patch State"
enum PatchState {
    ACCEPTED
    APPLIED
    PENDING
    SUBMITTED
    VOIDED
}

"Search result object type"
enum SearchResultType {
    GROUP
    RECIPIENT
    USER
}

enum TaskStatus {
    NEW
    RESOLVED
    REVISIT
    UNRESOLVED
}

"User type"
enum UserType {
    BUSINESS
    DOMESTIC
}

"Waste stream type. REZ = Residual, RPC/RGL/RPM = Recyclable, BIO = Biodegradable"
enum WasteStream {
    BIO
    REZ
    RGL
    RPC
    RPM
}

input BillScheduleInput {
    endMonth: Int!
    startMonth: Int!
    year: Int!
}

input FromToFilter {
    from: Int
    to: Int
}

input GroupInput {
    active: Boolean
    comments: String
    labels: [LabelEdit!]
    uatId: Int
}

input LabelEdit {
    "Name of label to perform operation on"
    name: String!
    "Operation"
    op: ArrayOp!
}

input RecipientInput {
    active: Boolean
    addressNumber: String
    addressStreet: String
    comments: String
    groupId: String
    labels: [LabelEdit!]
    locId: Int
    posLat: Float
    posLng: Float
    "Valid values are: 120L, 240L, 360L, 1.100L, S60, S120"
    size: String
    stream: WasteStream
    tags: [TagEdit!]
    uatId: Int
}

input TagEdit {
    "Operation"
    op: ArrayOp!
    "Slot of the transponder to add/remove. If -1 when adding, a slot is auto assigned. If -1 when removing, just the tag and not the slot position is considered"
    slot: Int
    "Transponder code of the tag to add/remove"
    tag: String!
}

input TaskInput {
    "Use empty string to set it to null. Can only be updated to empty string, but edited to any value"
    assignedTo: String
    comments: String
    "County ID. Can only be set when editing, not updating, a task"
    countyId: Int
    groupIds: [String!]
    "Loc ID. Can only be set when editing, not updating, a task"
    locId: Int
    posLat: Float
    posLng: Float
    recipientIds: [String!]
    status: TaskStatus
    "Uat ID. Can only be set when editing not updating a task"
    uatId: Int
    userIds: [String!]
}

input UserBillingInput {
    "Only applicable if billingType is FIXED"
    fixed: [UserBillingInputFixedCompoent!]
    "Number of persons. Only valid for PER_PERSON, PER_PERSON_RA types"
    persons: Int
    "Only applicable to PER_PERSON_RA types"
    ra: [UserBillingInputRAEntry!]
}

input UserBillingInputFixedCompoent {
    collections: Int!
    "Valid recipient size for component"
    size: String!
    stream: WasteStream!
}

input UserBillingInputRAEntry {
    "Year-Month to which this applies"
    month: String!
    "Whether RA is active for this month or not"
    value: Boolean!
}

input UserInput {
    active: Boolean
    addressNumber: String
    addressStreet: String
    billingData: UserBillingInput
    billingType: BillingType
    comments: String
    "Group this user belongs to. Set to special value 000000 to set to group to NULL"
    groupId: String
    idNumber: String
    labels: [LabelEdit!]
    locId: Int
    name: String
    uatId: Int
}


"UNIX Timestamp"
scalar Timestamp